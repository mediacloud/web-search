# Generated by Django 4.1.13 on 2026-02-04 22:04

from django.contrib.postgres.indexes import GinIndex
from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('sources', '0037_trigram_extension'),
    ]

    operations = [
        # As a rule this tries to reference PostgreSQL v16 documentation, since that's
        # what is in use at the time this was written (Feb 2026)!

        # Add a trigram based GIN index to speed up ILIKE operations; Trigram matching is
        # TOO fuzzy, and similarity scores depend on string sizes).  The trigram extension
        # is enabled in the previous migration to allow this migration to be reversible,
        # which was VERY helpful in development, trying different formulations.

        # Both GIN and GiST indexes are possible, the choice is clear as mud!

        # https://www.postgresql.org/docs/9.0/pgtrgm.html says:
        #   "As a rule of thumb, a GIN index is faster to search than a GiST index, but
        #   slower to build or update; so GIN is better suited for static data and GiST
        #   for often-updated data."
        # while the version 16 documentation says only:
        #   "The choice between GiST and GIN indexing depends on the relative performance
        #   characteristics of GiST and GIN, which are discussed elsewhere."
        # (WITHOUT a link to "elsewhere"!)
        
        # https://stackoverflow.com/questions/20416932/postgres-hstore-gin-vs-gist-index-performance
        # from 2013(!!) says(*):
        # * GIN index lookups are about three times faster than GiST
        # * GIN indexes take about three times longer to build than GiST
        # * GIN indexes are about ten times slower to update than GiST
        # * GIN indexes are two-to-three times larger than GiST
        #       (*) the page links to
        #       https://www.postgresql.org/docs/current/textsearch-indexes.html
        #       and covers indexes to use with tsvectors, not
        #       trigrams, and does NOT contain the above quoted values
        #       but docs for versions 9.0 thru 9.4 do.
        # BUT the initial poster did NOT find GIN faster, and
        # the consensus seems to have been "Use GiST"

        # https://www.postgresql.org/docs/16/textsearch-indexes.html 
        # (which, again relates to text search and indexing tsvectors) says:
        #   "GIN indexes are the preferred text search index type."
        #
        # https://www.postgresql.org/docs/16/pgtrgm.html#PGTRGM-INDEX says:
        #   "The pg_trgm module provides GiST and GIN index operator classes that allow
        #   you to create an index over a text column for the purpose of very fast
        #   similarity searches. These index types support the above-described similarity
        #   operators, and additionally support trigram-based index searches for LIKE,
        #   ILIKE, ~, ~* and = queries. The similarity comparisons are case-insensitive in
        #   a default build of pg_trgm."
        # and:
        #   "Unlike B-tree based searches, the search string need not
        #   be left-anchored."
        #
        # https://www.postgresql.org/docs/16/indexes-multicolumn.html says:
        # both GIN and GiST indexes
        #   "can be used with query conditions that involve any subset
        #   of the index's columns."
        #
        # BUT:
        #   "Multicolumn indexes should be used sparingly."
        # https://www.postgresql.org/docs/16/indexes-bitmap-scans.html says:
        #   "Sometimes multicolumn indexes are best, but sometimes it's better to create
        #   separate indexes and rely on the index-combination feature."
        #
        # https://www.postgresql.org/docs/16/indexes-index-only-scans.html#INDEXES-INDEX-ONLY-SCANS says:
        #   "GiST and SP-GiST indexes support index-only scans for some operator classes
        #   but not others. Other index types have no support. The underlying requirement
        #   is that the index must physically store, or else be able to reconstruct, the
        #   original data value for each index entry. As a counterexample, GIN indexes
        #   cannot support index-only scans because each index entry typically holds only
        #   part of the original data value.
        #
        # A two-column GIN index seemed to work well enough (100x speedup),
        #   select pg_relation_size('sources_source_name_label_trigram_gin_index');
        # shows the index is 182MB which seems manageable, so exploration stopped with the
        # first try (two column GIN index) and the alternatives (one column vs two, and
        # GIN vs GiST) have not been explored.
        #
        # If you decide to change the indexing, you can test
        # using the manage.py search command to see how it behaves!

        migrations.AddIndex(
            model_name='source',
            index=GinIndex(
                fields=['name', 'label'],
                opclasses=['gin_trgm_ops', 'gin_trgm_ops'],
                name='source_name_label_gin_index'),
        ),

        # FINALLY, this migration leaves the tsvector column and index in place so old
        # search code can be left in place as a fallback.
    ]
